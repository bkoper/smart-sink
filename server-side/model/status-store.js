import settnigsStore from './settings-store';import {EventEmitter} from 'events';import {mean} from 'lodash';class StatusStore extends EventEmitter {    constructor() {		super();        this.reset();    }    getData() {        return this.data;    }    setData(newData) {        newData.streamOpenTime = this.data.streamOpenTime;        newData.currentWaterFlown = this.data.currentWaterFlown;        newData.limitCrossedTimes = this.data.limitCrossedTimes;        newData.longestOpenedMinutes = this.data.longestOpenedMinutes;        newData.avg = this.data.avg || 0;        newData.speed = newData.speed || 0;        newData.percentSpeed = newData.percentSpeed || 0;                if(newData.speed > 0) {            if(!this.statistics.isStreamOpen) {                this.statistics.openStreamTimeStamp = +(new Date()).getTime();            }            newData.avg = parseFloat(newData.total / this.statistics.streamCount).toFixed(2);            this.statistics.isStreamOpen = true;            // limit crossed per stream open            newData.currentWaterFlown = parseFloat(newData.total - this.statistics.totalUsageOnLastStreamOpen).toFixed(2);            if(!this.statistics.limitCrossedLock && (newData.streamOpenTime > settnigsStore.getState().streamLimit)) {                this.statistics.limitCrossedLock = true;                newData.limitCrossedTimes++;            }            newData.streamOpenTime =                Math.round(((new Date()).getTime() - this.statistics.openStreamTimeStamp) / 1000);            if (newData.streamOpenTime  > newData.longestOpenedMinutes) {                newData.longestOpenedMinutes = newData.streamOpenTime;            };        } else {            if(this.statistics.isStreamOpen) {                this.statistics.streamCount++;            };            this.statistics.isStreamOpen = false;            this.statistics.limitCrossedLock = false;            this.statistics.totalUsageOnLastStreamOpen = this.data.total;            this.statistics.openStreamTimeStamp = +(new Date()).getTime();            newData.currentWaterFlown = 0;            newData.streamOpenTime = 0;        }        this.data.avg = Math.abs(mean([newData.avg, this.data.avg]));        this.data = newData;        this.emit(StatusStore.events.CHANGE, newData);    }	on(listener) {		this.addListener(StatusStore.events.CHANGE, listener);	}    reset() {        this.data = {            currentSpeed: 0,            speedPercent: 0,            total: 0,            avg: 0,            streamOpenTime: 0, // since last stream open            currentWaterFlown: 0, // since last stream open            limitCrossedTimes: 0,            longestOpenedMinutes: 0        };        this.statistics = {            totalTickCounter: 0,            openStreamTimeStamp: +(new Date()).getTime(),            limitCrossedLock: false, // it locks to check crossed limit once per open stream session            totalUsageOnLastStreamOpen: 0,            streamCount: 1,            isStreamOpen: false        }    }};StatusStore.events = {	CHANGE: "STATUS_CHANGE"};const coldStatusStore = new StatusStore();const hotStatusStore = new StatusStore();export {coldStatusStore, hotStatusStore};